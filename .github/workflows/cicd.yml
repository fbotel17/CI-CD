name: CI-CD CRUD API

on:
  push:
    tags:
      - "v*.*.*" # ex : v1.0.0, v2.3.1

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest

    steps:
      # 1) Récupération du code source depuis GitHub
      - name: Checkout repository
        uses: actions/checkout@v4

      # 2) Extraction de la version depuis le tag Git
      - name: Extract version from tag
        id: extract_version
        run: |
          # GITHUB_REF ressemble à : refs/tags/v1.2.3
          RAW_REF="${GITHUB_REF#refs/tags/}"   # -> v1.2.3

          # On enlève le 'v' pour avoir juste 1.2.3
          VERSION="${RAW_REF#v}"               # -> 1.2.3

          echo "Tag brut : $RAW_REF"
          echo "Version sans v : $VERSION"

          # On expose ces valeurs comme outputs du step
          echo "TAG=$RAW_REF" >> $GITHUB_OUTPUT
          echo "VERSION=$VERSION" >> $GITHUB_OUTPUT

      # 3) Connexion à Docker Hub
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password:
            ${{ secrets.DOCKERHUB_TOKEN }}

            # 4) Build de l'image Docker de l'API CRUD
      - name: Build API Docker image
        run: |
          docker build -t ${{ secrets.DOCKERHUB_USERNAME }}/crud-api:${{ steps.extract_version.outputs.VERSION }} ./App

      # 4b) Push de l'image versionnée
      - name: Push API Docker image (version)
        run: |
          docker push ${{ secrets.DOCKERHUB_USERNAME }}/crud-api:${{ steps.extract_version.outputs.VERSION }}

      # 4c) Tag et push du latest
      - name: Push API Docker image (latest)
        run: |
          docker tag ${{ secrets.DOCKERHUB_USERNAME }}/crud-api:${{ steps.extract_version.outputs.VERSION }} \
                     ${{ secrets.DOCKERHUB_USERNAME }}/crud-api:latest
          docker push ${{ secrets.DOCKERHUB_USERNAME }}/crud-api:latest

      # 5) Build de l'image Fluent Bit
      - name: Build Fluent Bit Docker image
        run: |
          docker build -t ${{ secrets.DOCKERHUB_USERNAME }}/fluentbit:${{ steps.extract_version.outputs.VERSION }} ./fluentbit

      # 5b) Push de l'image Fluent Bit versionnée
      - name: Push Fluent Bit Docker image (version)
        run: |
          docker push ${{ secrets.DOCKERHUB_USERNAME }}/fluentbit:${{ steps.extract_version.outputs.VERSION }}

      # 5c) Tag et push du latest
      - name: Push Fluent Bit Docker image (latest)
        run: |
          docker tag ${{ secrets.DOCKERHUB_USERNAME }}/fluentbit:${{ steps.extract_version.outputs.VERSION }} \
                     ${{ secrets.DOCKERHUB_USERNAME }}/fluentbit:latest
          docker push ${{ secrets.DOCKERHUB_USERNAME }}/fluentbit:latest

      # 6) Authentification et création explicite du fichier de clé pour Docker
      - name: Create Service Account Key File
        run: echo '${{ secrets.GCP_SA_KEY }}' > key.json

      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}

      - name: Setup Google Cloud SDK
        uses: google-github-actions/setup-gcloud@v2
        with:
          project_id: ${{ secrets.GCP_PROJECT_ID }}

      # 7) Démarrage du Proxy SQL
      # On ajoute un sleep pour être sûr qu'il est prêt
      - name: Start Cloud SQL Proxy
        run: |
          docker run -d \
            --name cloud-sql-proxy \
            --restart always \
            -p 3306:3306 \
            -v "$(pwd)/key.json":/key.json:ro \
            gcr.io/cloudsql-docker/gce-proxy:1.33.3 \
              /cloud_sql_proxy \
              -instances=${{ secrets.DB_INSTANCE_CONNECTION_NAME }}=tcp:0.0.0.0:3306 \
              -credential_file=/key.json

          # Attendre un peu que le proxy démarre
          sleep 10

          # Afficher les logs pour vérifier si ça a planté
          docker logs cloud-sql-proxy

      # 7b) Flyway migrations
      - name: Run Flyway migrations
        run: |
          docker build -t migrations-image ./migrations

          # --network host permet au conteneur d'accéder au port 3306 du runner (où tourne le proxy)
          docker run --rm \
            --network host \
            -e FLYWAY_URL="jdbc:mysql://127.0.0.1:3306/${{ secrets.DB_NAME }}" \
            -e FLYWAY_USER="${{ secrets.DB_USER }}" \
            -e FLYWAY_PASSWORD="${{ secrets.DB_PASSWORD }}" \
            migrations-image migrate

      # 8) Génération du fichier Cloud Run à partir du template
      - name: Generate Cloud Run service file
        run: |
          sed "s/{{DOCKER_USERNAME}}/${{ secrets.DOCKERHUB_USERNAME }}/g;
               s/{{VERSION}}/${{ steps.extract_version.outputs.VERSION }}/g;
               s/{{DB_USER}}/${{ secrets.DB_USER }}/g;
               s/{{DB_PASSWORD}}/${{ secrets.DB_PASSWORD }}/g;
               s/{{DB_NAME}}/${{ secrets.DB_NAME }}/g;
               s/{{LOKI_URL}}/${{ secrets.LOKI_URL }}/g;" \
               cloud-run-service.yaml.tmpl > cloud-run-service.yaml

          echo "Fichier Cloud Run généré :"
          cat cloud-run-service.yaml

      # 9) Déploiement Cloud Run
      - name: Deploy to Cloud Run
        run: |
          gcloud run services replace cloud-run-service.yaml \
            --region ${{ secrets.GCP_REGION }} \
            --project ${{ secrets.GCP_PROJECT_ID }}

      # 9b) Rendre le service public
      - name: Allow unauthenticated access
        run: |
          gcloud run services add-iam-policy-binding crud-api \
            --region ${{ secrets.GCP_REGION }} \
            --role roles/run.invoker \
            --member "allUsers"
